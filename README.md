# Zemrow Messenger

<!-- TODO ссылки на readme на других языках -->
## Что такое Zemrow Messenger? 
<!--EN: What is Zemrow Messenger? -->

Веб приложение объединяющее функционал месенджера, создания и ведения задач, с возможностью автоматизации процессов.

## Перед начолом
<!--EN: Prerequisites -->
На компьютере должны быть установлены [Java JDK 8 или выше](http://www.oracle.com/technetwork/java/javase/downloads/index.html), [Git](https://git-scm.com/downloads) 

## Как запустить 
<!--EN: Getting Started -->
- скачать исходники
```git clone https://github.com/a-polyakov/com.zemrow.messenger.git```
- запустить сборку
```gradlew jar```
- исполняемый файл находится ```build/libs/messanger.jar```
- запустить сервер
```java -jar messanger.jar```

<!--
TODO Аргументы:
TODO порт запуска WEB сервера как параметр
TODO список ip узлов в кластере
-->

## Технические детали
Клиентская часть реализована на [jQuery](https://jquery.com/).
За получение и обработку запросов отвечает [Undertow](http://undertow.io/).
Взаимодействие осуществляется по протоколу rest и websocket.
Приложение может работать как в одном экзампляре так и объединить множество узлов в кластер, так как базируется на 
[Apache Ignite](https://ignite.apache.org) – это высокопроизводительная, распределённая in-memory платформа для вычислений, 
обработки и хранения данных.
Что позволило легко кластеризовать приложение, получив при этом высокую производительность и надежность.
<!--
TODO Android и IOS приложение представляют из себя фоновый процесс получния уведомлений,
а при переходе в уведомление происходит открытие штатного браузера 
-->

## Диаграма взаимодействия компонентов
![request_diagram.png](readme/request_diagram.png)
1. Пользователь взаимодействует с клиентским приложением (это может быть ПК, телефон или другое устройство с WEB браузером) 
у одного пользователя может быть несколько одновременно используемых подключений.
2. Клиентское приложение отправляет запрос на сервер (WebSocket).
3. Cервер получает запрос анализирует и отправляет на соответствеющий контролер.
4. Контролер конвертирует данные и передает их в сервис.
5. Серсив выполняет необходимые ему действия (часть из которых может выполнить вне транзакции). 
6. В нутри транзакции серсис вызывать один или больше логических блоков.
7. Логический блок служат для реализации ссылочной целостности и реализации ограничений (так как ignite на текущий момент не поддерживает constrain).
8. Логический блок использует DAO для взаимодействия с хранилищем (как операции получения и записи по ключу так и sql запросы).
9. Передача ответа.
10. Передача ответа.
11. Передача ответа.
12. Котролеру может понадобится несколько манипуляций с хранилищем.
13. Запрос.
14. Запрос.
15. Ответ.
16. Ответ.
17. Логическому блоку тоже может понадобиться несколько манипуляций с хранилищем.
18. Запрос.
19. Ответ.
20. Ответ.
21. Ответ.
22. Сервис получает ответ и закрывает транзакцию, дополняет ответ областью видимости.
23. Конторлер анализирует область видимости и определяет сервера которым необходимо отправить ответ.
24. Сервер который должнен отправить отмет может быть не один.
24. Сервер по имеющемуся соединению уведомляем пользовательское приложение.
25. Пользовательских приложений может быть много. 
  
## Схема данных

![database_schema.png](readme/database_schema.png)

## Работа с мессенджером

Работа с мессенджером схожа с работой распространенных аналогов, поэтому остановимся на ключевых особеностях:

Задание это такойже чат с отображением ключевых элевентов в шапке чата.
Управление чатами/заданиями производится отправкой служебных сообщений 
такое сообщение содержит команды котрые начинаются с !(восклицательный знак)
- !добавить_собеседника
- !удалить_собеседника
- !покинуть_чат 
- !добавить_собеседника_с_историей
- !удалить_собеседника_с_историей
- !переименовать
- !задание
- !исполнитель
- !срок_выполнения
- !работа_начата
- !работа_приостановленна
- !работа_окончена
- !приватный_чат
- !статус
- !оценка_времени
- !описание
- !дата_проведения
- !место_проведения
- !ожидаемый_результат
- !фактический_результат
служебное сообщение может содержать параметры, которые могут быть обязательными тогда при их отсутствии система сообщит вам об этом
одно сообщение может содержать несколько команд

используя этот механизм можно расширять функциональность системы не меняя при этом клиентскую часть

<!--TODO добавить механизм голосования-->

## Концепция UI (user interface - пользовательский интерфейс)

Разобъем интерфейс на три роли: исполнитель, руководитель, логист
- Исполнитель, должен видеть задачи которые ему необходимо сделать, в простейшем случае задачник отсортированый по приоритету, 
исполнитель берет задачу с наивысшим приоритетом о выполняет ее.
- Руководитель, распределяет имеющиеся задачи между исполнителями орентируясь на загрузку, 
следит за прогрессом выполнения задач, 
определяет качество и скорость работы. Для этих задач хорошо себя зарекоментовада доска Kanban
таблица где столбцы по статусу задач, колонки задачи отсортированые по приоритету (важные вверху) с возможностью групировки по исполнителям. 
- Логист создает задачи, детализирует задачи, осуществляет планирование, оценку задач по времени и приоритету.

При этом пользователь может выполнять лубую из ролей ну и конечно же совмещать

<!--TODO отчеты-->

## Концепция ботов

Система должна предоставлять набор готовых и настраиваемых ботов, которые являются такимиже пользователями мессенжера и имеют теже возможнасти,
задача их следить да происходящим в чате/задании и реагировать:
- уведомлять о нарушении бизнес процесса при смене статуса
- уведомлять о приблежении срока
- интеграция со стороними системами 
  - при наступление события в стороней системе сообщать об этом в чате
  - при определеных сообщениях в чате выполнять действие в стороней системе 

в общем случае анализировать текущее состояние и возможно предпринимать какието действия

<!--TODO список публичных и приватных задач -->
<!--TODO место выделеное пользователю -->
<!--TODO плитка задачи - отображене задачи с подзадачами, отображать сроки, при переносе отображать перенос (старую дату зачеркнутой)-->
<!--TODO как правильно строить приоритет
 перенос задачи выше обновляет все задачи в диапазоне
 -->
<!--TODO темплейт задач (задача из шаблонных этапов которые проще подправить чем писать с нуля) -->

## Рекомендации по настройке JVM
Подробно можно посмотреть в [офицеальной документации](https://apacheignite.readme.io/docs/jvm-and-system-tuning).

Ниже приведены параметры для узла с 16Gb оперативной памяти

- ```-server``` - Включить оптимизацию для работы сервера  
- ```-Xms4g``` - Исходный размер кучи
- ```-Xmx4g``` - Максимальный размер кучи
- ```-XX:MaxDirectMemorySize=10g``` - Память не проверяемая сборщиком мусора, используется явными функциями получения и освобождения памяти (нативный код на Си)
- ```-XX:+AlwaysPreTouch``` - Обнулить всю память при старте приложения (замедляет старт, но убирает необходимость очищать память перед использованием)
- ```-XX:+DisableExplicitGC``` - Отключить обработку System.gc()
- ```-XX:+ScavengeBeforeFullGC``` - Перед Full GC запуск GC на young generation
> OutOfMemoryError 
- ```-XX:GCHeapFreeLimit=5``` - Если после Full GC осталось меньше X памяти (целое число - память в процентах), то кидается OutOfMemoryError. По умолчанию 2, увеличив спасает от случаев когда память вплотную подходит к концу и приложение только и делает что занимается сборкой мусора
- ```-XX:+HeapDumpOnOutOfMemoryError``` - Сохранять дамп памяти при OutOfMemoryError
- ```-XX:HeapDumpPath=dump.hprof``` - Куда сохранять дамп памяти при OutOfMemoryError 
> G1 
- ```-XX:+UseG1GC``` - Включает сборщик мусора G1
- ```-XX:MaxGCPauseMillis=200``` - Максимальное время пауз при сборке 
- ```-XX:GCPauseIntervalMillis=5000``` - Выдерживать паузы не менее указаной, между сборками мусора
  ```
- ```-XX:+PrintGCDetails``` - Включить логирование сборщика мусора 
- ```-XX:+PrintGCTimeStamps``` - Отображать время в логе сборщика мусора
- ```-XX:+PrintGCDateStamps``` - Отображать дату в логе сборщика мусора
- ```-XX:+UseGCLogFileRotation``` - Ротировать логе сборщика мусора
- ```-XX:NumberOfGCLogFiles=10``` - Максимальное количество файлов в логе сборщика мусора
- ```-XX:GCLogFileSize=100M``` - Максимальный размер одного файла в логе сборщика мусора  
- ```-Xloggc:gc.log``` - Запись логов в файл
- ```-XX:+DebugNonSafepoints``` - Возможность снимать stack trace вне safepoint, необходимо для более точного профилирования
- ```-XX:+PreserveFramePointer``` - TODO
- ```-DIGNITE_QUIET=false``` - TODO

TODO
-XX:G1NewSizePercent=1 -XX:G1MaxNewSizePercent=5 -XX:+PrintSafepointStatistics -XX:+LogVMOutput
https://gist.github.com/svanoort/66a766ea68781140b108f465be45ff00
  
